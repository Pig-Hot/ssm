https://blog.csdn.net/linzhiqiang0316/article/details/80473906
1.面向对象的三大特征: 封装，继承，多态
2.多态的优势:允许不同类对象对相同的消息(方法)做出不同响应
    1.可替换性:多态对已存在的代码具有可替换性
    2.可扩充性:增加新的子类不影响已经存在的类结构
    3.接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的
3.代码中实现多态的方法:接口实现，继承父类重写的方法，同一个类进行方法重载
4.虚拟机实现多态的方法:动态绑定技术，执行期间判读引用对象的实际类型，根据实际类型调用相应的方法
5.接口的抽象类的区别:单继承多实现，接口的意义是制定规范，扩展，回调，抽象类的意义为其他子类提供模板，封装重复定义的类容
6.父类的静态方法不能被子类重写，静态变量存储于方法区
7.不可变对象:不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类
8.java创建对象的几种方式:
    1.NEW对象
    2.通过反射
    3.采用clone
    4.通过序列号机制
9.switch在jdk1.7之后可以使用string做参数，不能做在long对象上
10.String s1='ab',s2='a'+'b'.s3='a',s4='b',s5=s3+s4,s2==s5?
    false,编译过程中s2会被优化成‘ab’,会被放在常量池中,s5在堆中
11.String对象的intern():首先会从常量池查找是否存在该常量池，不存在创建，存在直接返回
12.Object方法: equals,toString,clone,notify,getClass
12.java四种引用
    1.强引用:不会被GC，哪怕内存空间不足出现OOM也不会被JVM回收，如果想要中断强引用，可以显示的将代码设置为null，就会被回收
    2.软引用:内存不足时，被JVM回收
    3.弱引用:当JVM进行垃圾回收时，一旦发现就会回收
    4.虚引用:任何时候都可能会被回收
13.Weak(弱)Reference与Soft(软)Reference的区别:虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakRefe
    -rence ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候
14.不同引用类型使用场景
   1.利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这
   些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.
   2.通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构
   建一个实例，这将引起大量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。此时，通过软引用和 HashMap 的结
   合可以构建高速缓存，提供性能。
15.==、equals、hashcode：
    1.==是运算符，用于比较两个变量是否相等，而equals是Object类的方法，用于比较两个对象是否相等
    2.基本类型比较用==，比较的是他们的值。默认下，对象用==比较时，比较的是内存地址，如果需要比较对象内容，需要重写equal方法
    3.hashCode()是Object类的一个方法，返回一个哈希值。如果两个对象根据equal()方法比较相等，那么调用这两个对象中任意一个对象的hashCod
    e()方法必须产生相同的哈希值。
16.a=a+b与a+=b有什么区别:a+=b隐式类型转换
17.深拷贝和浅拷贝:浅拷贝引用仍然指向原来的对象，仅仅拷贝对象，深拷贝拷贝引用和对象
18.static用法：
    1.修饰变量和方法，属于类的静态资源，类实例共享
    2.静态代码块，用于初始化
    3.静态修饰内部类
    4.静态导包
19.final用法:
   1.被final修饰的类不可以被继承
   2.被final修饰的方法不可以被重写
   3.被final修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变。
   4.被final修饰的方法，JVM会尝试将其内联，以提高运行效率
   5.被final修饰的常量，在编译阶段会存入常量池中。
20.关于垃圾回收(这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析):
    1. 标记-清除
    2. 标记-复制
    3. 标记-整理
    4. 分代回收
21.线程与进程区别:进程是程序运行资源分配的最小单位，线程是CPU调度分派的最小单位
22.synchronized和ReentrantLock的区别:ReentrantLock比synchronized灵活，可以扩展，底层实现ReentrantLock底层调用的是Unsafe的park
方法加锁，synchronized操作的应该是对象头中mark word
23.Java有哪几种锁:
    1.自旋锁
    2.偏向锁
    3.轻量级锁
24.ThreadLocal：就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没
有线程安全方面的问题了